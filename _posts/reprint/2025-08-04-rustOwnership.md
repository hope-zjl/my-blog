---
title: "Rust所有权：别再死记硬背了！把智能指针当“玩具”玩，三巨头(Box, Rc, RefCell)让你秒懂内存管理"
date: 2024-03-31 00:05:42 +0800
categories: [转载, rust]
tags: [所有权, Box, Rc, RefCell]     # TAG names should always be lowercase
mermaid: true
comments: true
---

嘿，朋友！还在被 Rust 的所有权系统搞得头昏脑胀吗？什么借用、生命周期的，是不是感觉像在考一本永远也搞不懂的法律条文？  
别怕，今天咱们不讲那些大道理。咱们把代码世界想象成一个游乐场，把数据想象成心爱的玩具，看看 Rust 是怎么通过几个“智能”的“玩具箱”（也就是智能指针），让内存管理变得既安全又有趣的。

### 一号玩具箱：`Box<T>` —— “这玩具太大了，我家放不下！”

想象一下，你买了个超酷的乐高千年隼号，但它太大了，你的小房间（栈 Stack）根本放不下。怎么办？  
  
你老妈（编译器）说：“傻孩子，放不下就租个外面的储物柜（堆 Heap）嘛！”  
  
`Box<T>` 就是那个帮你租储物柜、再把玩具放进去的“万能箱子”。  
  
它很简单，就干一件事：把你的数据从栈上，搬到堆上。而你手里呢？只用拿着一张指向储物柜的“钥匙”（也就是指针）。这张“钥匙”本身很小，你的房间（栈）肯定放得下。
  
```rust
// 房间（栈）里放不下 100 万个整数
// let a = [0; 1000000]; // 这可能会让程序崩溃

// 用 Box 把它放到外面的储物柜（堆）里
let b = Box::new([0; 1000000]); // 轻松搞定！
```
  
最关键的是，这个“储物柜”的钥匙，同一时间只能有一个主人。你把钥匙给了你的朋友，你就不能再用了。这，就是`Box<T>`的单一所有权。当“你”（持有Box的变量）离开游乐场（作用域）时，Rust 会自动帮你把储物柜退掉，里面的玩具也销毁了，干干净净，绝不健忘。

> 什么时候用它？
{: .prompt-info }
  
1. 当你的“玩具”太大，栈上放不下时。
2. 当你需要一个“玩具”清单，但清单里每个玩具的大小都不一样时（特征对象 `Box<dyn Trait>`）。
3. 当你创造了一个会“自己生自己”的递归玩具时（比如链表）。
  
### 二号玩具箱：`Rc<T>` —— “我的玩具，大家可以一起看！”
  
现在，你有一个绝版的漫画书（一份数据），你的好几个朋友（代码的不同部分）都想看。
  
如果用`Box`，你把漫画书（所有权）给了朋友A，朋友B和C就没得看了。这显然不行，友谊的小船说翻就翻。
  
于是，`Rc<T>`（Reference Counting，引用计数）闪亮登场！它像一个“图书管理员”。
  
`Rc<T>`会把你的漫画书放在一个公共阅览室（还是在堆上），然后给每个想看的朋友发一张“借书卡”（克隆一个Rc指针）。它内部有一个计数器，记录着现在有多少张“借书卡”被发出去了。
  
```rust
use std::rc::Rc;

// 把漫画书《Rust从入门到放弃》用 Rc 管理起来
letbook = Rc::new(String::from("Rust从入门到放弃"));

println!("当前借阅人数: {}", Rc::strong_count(&book)); // 输出 1，只有你自己

// 朋友A借走了
letfriend_a = Rc::clone(&book);
println!("当前借阅人数: {}", Rc::strong_count(&book)); // 输出 2

// 朋友B也借走了
letfriend_b = Rc::clone(&book);
println!("当前借阅人数: {}", Rc::strong_count(&book)); // 输出 3
```
  
当一个朋友看完，把“借书卡”销毁时（变量离开作用域），计数器就减一。当计数器归零，说明没人再看这本漫画书了，图书管理员Rc就会把书处理掉，回收内存。
  
但是，记住！ `Rc<T>`管理的玩具，大家只能看，不能改！谁要是敢在上面乱涂乱画（修改数据），编译器第一个就冲过来打你屁股。这是为了安全，防止数据竞争嘛。

### 三号玩具箱：`RefCell<T>` —— “悄悄告诉你，我有办法在大家看的时候修改它”

“只能看不能改？这也太不灵活了吧！” 你可能会抱怨。
  
别急，Rust 提供了一个“作弊神器”，一个真正的黑魔法——`RefCell<T>`。
  
`RefCell<T>` 就像一个带有运行时锁的透明展示柜。在正常情况下，它和Rc一样，允许多个人“围观”（共享引用）。但它偷偷提供了一把特殊的钥匙，可以让你在运行时（程序跑起来的时候）申请“临时修改权”。
  
它绕过了编译器的静态借用检查，把检查工作推迟到了运行时。
  
```rust
use std::cell::RefCell;

let shared_data = RefCell::new(5);

// 大家都能看
println!("原始数据: {:?}", shared_data.borrow());

// 我想改一下，申请一个可变借用
let mut mutable_borrow = shared_data.borrow_mut();
*mutable_borrow += 1;

// 改完后，别人看到的就是新数据了
println!("修改后数据: {:?}", shared_data.borrow()); // 输出 6
```
  
> 听起来很爽？但黑魔法总是有代价的！
{: .prompt-info }
  
`RefCell<T>`的代价就是：如果你不遵守规则，它不会在编译时告诉你，而是在运行时直接让你的程序崩溃（panic）！
  
它的规则是：
  
- 在任何时候，你只能有一个“可变借用”（`borrow_mut`）。
- 当你拥有一个“可变借用”时，不能再有任何“不可变借用”（`borrow`）。
  
如果你同时申请两个`borrow_mut`，或者在`borrow_mut`还存在的时候去`borrow`，程序就会大喊一声“你违规了！”然后原地爆炸。
  
### 终极合体：`Rc<RefCell<T>>` —— 共享所有权，还能内部修改！
好了，现在我们把二号和三号玩具箱合体，就得到了终极神器 `Rc<RefCell<T>>`。
  
`Rc` 负责让多个所有者可以共享这个“透明展示柜”。  
`RefCell` 负责让拥有权限的人，可以在运行时修改柜子里的东西。
  
这就是你在需要“多重所有权”和“可变性”时的完美解决方案。比如，在一个图结构里，一个节点可能被多个其他节点引用，并且它自身的状态还需要被修改。
  
> 总结一下，怎么选？
{: .prompt-info }

- 想把大东西放堆上，并且主人只有一个？用 `Box<T>`。
- 想让数据被多个部分共享只读？用 `Rc<T>`。
- 想在单线程里，临时“打破”借用规则，实现内部可变？用 `RefCell<T>`。
- 想让数据被多个部分共享，并且还能修改？用 `Rc<RefCell<T>>`。
- （悄悄预告）如果是在多线程环境下玩共享和修改？那就要请出原子引用计数 Arc 和互斥锁 `Mutex` 了，我们下回分解！
  
看，通过这些生动的“玩具箱”，Rust的所有权和内存管理是不是瞬间变得眉清目秀了？